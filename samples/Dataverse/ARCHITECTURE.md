# Architecture

## Overview

The Dataverse Demo App uses a three-layer architecture with clear separation between UI rendering, business logic, and data access. This keeps each layer independently testable and easy to reason about.

```
┌──────────────────────────────────────┐
│  Presentation Layer  (Components)    │  UI only — no business logic
├──────────────────────────────────────┤
│  Business Logic Layer  (Hooks)       │  State, async ops, orchestration
├──────────────────────────────────────┤
│  Data Layer  (Generated Services)   │  Dataverse Web API — auto-generated
└──────────────────────────────────────┘
```

---

## Layer 1: Presentation (Components)

**Location:** `src/components/`

Components are pure and presentational. They receive data via props and emit events via callbacks. No direct service calls, no business logic.

| Component | Responsibility |
|-----------|----------------|
| `Header` | App title and description |
| `ErrorMessage` | Conditional error banner |
| `ContactList` | Grid of cards + "New Contact" button |
| `ContactCard` | Single contact display with Edit/Delete actions |
| `ContactForm` | Create/edit form with lookup dropdown |
| `Footer` | Informational footer |

---

## Layer 2: Business Logic (Hooks)

**Location:** `src/hooks/`

Custom hooks encapsulate all state and async operations. They are the only place that calls generated services.

| Hook | Responsibility |
|------|----------------|
| `useContacts` | Contact CRUD operations, form state (create/edit/cancel), error handling |
| `useAccounts` | Loads account list for the "Managing Partner" dropdown |
| `useLookupResolver` | Resolves lookup GUIDs to display names on-demand |

### Hook interface example

```typescript
const {
  contacts,          // Contact[]
  loading,           // boolean
  error,             // string | null
  selectedContact,   // Contact | null
  isCreating,        // boolean
  startCreate,       // () => void
  startEdit,         // (contact: Contact) => void
  cancelForm,        // () => void
  handleFormSubmit,  // (data: FormData) => Promise<void>
  deleteContact,     // (id: string) => Promise<void>
} = useContacts();
```

---

## Layer 3: Data Access (Generated Services)

**Location:** `src/generated/`

Auto-generated by the PAC CLI. Never edit these files manually — regenerate them if the schema changes. They handle authentication and Dataverse Web API communication transparently.

| Service | Entity |
|---------|--------|
| `ContactsService` | `contact` |
| `AccountsService` | `account` |
| `SystemusersService` | `systemuser` |
| `TeamsService` | `team` |
| `TransactioncurrenciesService` | `transactioncurrency` |

Each service provides: `create()`, `get()`, `getAll()`, `update()`, `delete()`.

---

## Component Hierarchy

```
App
├── Header
├── ErrorMessage
├── [Content Grid]
│   ├── ContactList
│   │   ├── Section header (title + count + "New Contact" button)
│   │   └── ContactCard × N
│   │       ├── Contact info (name, title, email, phone)
│   │       ├── Lookup fields (Created By, Currency, Managing Partner, etc.)
│   │       └── Actions (Edit, Delete)
│   │
│   └── ContactForm  [conditional — create or edit mode]
│       ├── Section header (title + Cancel button)
│       ├── Input fields (First Name*, Last Name*, email, phone, job title)
│       ├── Managing Partner dropdown (lookup)
│       ├── Read-only lookup info (Created By, Currency, etc.)
│       └── Submit / Delete buttons
│
└── Footer
```

---

## Data Flow

```
User Action
    │
    ▼
Component  (emits event via callback prop)
    │
    ▼
Custom Hook  (handles state + async)
    │
    ▼
Generated Service  (calls Dataverse Web API)
    │
    ▼
Dataverse
    │
    ▼  (response flows back up)
Hook updates state → components re-render
```

### Props down, events up

Components receive data through props and communicate upward through callbacks:

```typescript
// App passes data and callbacks to children
<ContactList
  contacts={contacts}        // data down
  loading={loading}          // data down
  onEdit={startEdit}         // event up
  onDelete={deleteContact}   // event up
  onCreateNew={startCreate}  // event up
/>
```

---

## Event Flows

### Creating a contact

```
User clicks "New Contact"
    → ContactList.onCreateNew()
    → useContacts.startCreate()   (isCreating = true)
    → ContactForm renders

User fills form and submits
    → ContactForm.onSubmit(formData)
    → useContacts.handleFormSubmit()
    → useContacts.createContact()
        → Validate fields
        → Attach lookup via @odata.bind
        → ContactsService.create(payload)
        → Dataverse creates record
    → isCreating = false
    → loadContacts() refreshes list
    → ContactForm unmounts
```

### Editing a contact

```
User clicks "Edit" on a card
    → ContactCard.onEdit(contact)
    → useContacts.startEdit(contact)   (selectedContact = contact)
    → ContactForm renders pre-populated

User changes fields and submits
    → ContactForm.onSubmit(formData)
    → useContacts.updateContact()
        → Build diff of changed fields only
        → Handle lookup changes with @odata.bind
        → ContactsService.update(id, updates)
        → Dataverse updates record
    → selectedContact = null
    → loadContacts() refreshes list
```

### Deleting a contact

```
User clicks "Delete" on a card
    → useContacts.deleteContact(id)
        → Confirmation dialog
        → ContactsService.delete(id)
        → Dataverse deletes record
    → Clear form if this contact was being edited
    → loadContacts() refreshes list
```

---

## Props Flow Summary

### Downward (state → components)

```
useContacts
  ├── contacts       → ContactList → ContactCard
  ├── loading        → ContactList
  ├── error          → ErrorMessage
  ├── selectedContact → ContactForm
  └── isCreating     → ContactForm

useAccounts
  └── accounts       → ContactForm
```

### Upward (events → hooks)

```
ContactCard   → onEdit    → ContactList.onEdit    → useContacts.startEdit
ContactCard   → onDelete  → ContactList.onDelete  → useContacts.deleteContact
ContactList   → onCreateNew                       → useContacts.startCreate
ContactForm   → onSubmit                          → useContacts.handleFormSubmit
ContactForm   → onCancel                          → useContacts.cancelForm
```

---

## Component Responsibilities

| | UI Rendering | State | Business Logic | API Calls |
|---|---|---|---|---|
| **App** | Composition only | ✗ Delegates | ✗ Delegates | ✗ |
| **Header / Footer** | ✅ | ✗ | ✗ | ✗ |
| **ErrorMessage** | ✅ Conditional | ✗ | ✗ | ✗ |
| **ContactList** | ✅ Grid | ✗ | ✗ | ✗ |
| **ContactCard** | ✅ Card | ✗ | ✗ | ✗ |
| **ContactForm** | ✅ Form | ✅ Local form state | ✗ | ✗ |
| **useContacts** | ✗ | ✅ Contacts + form mode | ✅ All CRUD logic | ✅ Via services |
| **useAccounts** | ✗ | ✅ Accounts list | ✅ Load logic | ✅ Via services |
| **useLookupResolver** | ✗ | ✅ Resolved names | ✅ Fetch logic | ✅ Via services |
| **Generated Services** | ✗ | ✗ | ✗ | ✅ Dataverse API |

---

## Key Design Patterns

### Separation of Concerns

Each layer has one job. No component reaches into the data layer; no service knows about the UI.

### Single Responsibility

Each file has one clear purpose. `ContactCard` displays one contact. `useContacts` manages contact operations. `ContactsService` handles Dataverse communication.

### Composition Over Inheritance

Complex UI is built from simple, composed components. `ContactList` renders many `ContactCard` instances; `App` composes all top-level components.

### Custom Hooks for Logic Reuse

Business logic lives in hooks that can be:
- Tested independently of the UI
- Reused across components if needed
- Swapped out without changing components

---

## Error Handling

Three-level strategy:

```
Service Level   → Generated services throw on API errors
    ↓
Hook Level      → try-catch transforms to user-friendly message + console.error
    ↓
Component Level → ErrorMessage component renders the string from state
```

```typescript
// Hook level — catch and expose via state
try {
  await ContactsService.delete(id);
} catch (err) {
  setError(`Failed to delete contact: ${err.message}`);
  console.error('Delete error:', err);
}
```

```typescript
// Component level — display via props
<ErrorMessage error={error} />
```

---

## State Management

This app uses `useState` inside custom hooks — no Redux or Context API. The app is small enough that prop-drilling one level (App → child) is simpler and more explicit than global state.

If the app grows, consider:
- **React Query** for server state caching and background sync
- **Context API** for truly shared UI state (e.g., current user theme)
- **React Router** for multi-page navigation

---

## Performance

### Query optimization

Always use `select`, `top`, and `orderBy` to limit data transfer:

```typescript
ContactsService.getAll({
  select: ['contactid', 'firstname', 'lastname', '_msa_managingpartnerid_value'],
  orderBy: ['createdon desc'],
  top: 50,
});
```

### Lookup resolution

Lookup GUIDs are fetched per-contact on-demand using individual `Service.get()` calls rather than loading entire related tables. See [LOOKUPS.md](./LOOKUPS.md) for details.

### Conditional rendering

`ContactForm` only mounts when a contact is being created or edited, keeping the initial render lightweight.

---

## Testing Strategy

### Component tests

Mock the hook to isolate UI rendering:

```typescript
jest.mock('../hooks/useContacts');

test('ContactList renders contacts', () => {
  (useContacts as jest.Mock).mockReturnValue({
    contacts: mockContacts,
    loading: false,
  });
  // assert rendering
});
```

### Hook tests

Test hooks with React Testing Library's `renderHook`:

```typescript
test('useContacts loads contacts on mount', async () => {
  const { result } = renderHook(() => useContacts());
  await waitFor(() => {
    expect(result.current.contacts).toHaveLength(3);
  });
});
```

---

## Best Practices Demonstrated

- Component composition — complex UIs from simple, focused pieces
- Custom hooks for logic separation and reuse
- TypeScript throughout — generated models, typed props, typed hook returns
- Props down, events up — unidirectional data flow
- Loading and error states at every async boundary
- Generated services only — no raw fetch or axios calls
- Query optimization — select, top, orderBy on every `getAll()` call
- Efficient lookup resolution — individual `get()` instead of loading whole tables
