/**
 * useContacts Hook
 * Custom hook for managing contact CRUD operations
 *
 * This hook encapsulates all the business logic for:
 * - Loading contacts from Dataverse
 * - Creating new contacts
 * - Updating existing contacts
 * - Deleting contacts
 * - Error handling and loading states
 *
 * ARCHITECTURE PATTERN:
 * This hook acts as the "controller" layer between UI components and services.
 * It manages state, orchestrates service calls, and handles errors.
 * Components remain pure and presentational by delegating all business logic here.
 *
 * ERROR HANDLING PATTERN:
 * Three-level error handling throughout:
 * 1. Service layer catches network/API errors
 * 2. Hook sets user-friendly error messages in state
 * 3. Technical details logged to console for debugging
 */

import { useState, useEffect } from 'react';
import { ContactsService } from '../generated/services/ContactsService';
import type { Contacts } from '../generated/models/ContactsModel';
import type { ContactFormData } from '../components/ContactForm';

// Constants for query limits
const MAX_CONTACTS_TO_LOAD = 50;
const DEFAULT_SORT_ORDER = 'createdon desc';

export function useContacts() {
  const [contacts, setContacts] = useState<Contacts[]>([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const [selectedContact, setSelectedContact] = useState<Contacts | null>(null);
  const [isCreating, setIsCreating] = useState(false);

  /**
   * Load all contacts from Dataverse on mount
   */
  useEffect(() => {
    loadContacts();
  }, []);

  /**
   * READ: Fetch all contacts from Dataverse
   * Uses the generated ContactsService.getAll() method
   *
   * BEST PRACTICE: Always use 'select' to request only needed fields
   * - Improves performance by reducing payload size
   * - Reduces network bandwidth usage
   * - Makes code self-documenting (clear which fields are used)
   *
   * LOOKUP FIELDS: Returned with pattern _<schemaname>_value containing the GUID
   * - _createdby_value: GUID of the user who created the record
   * - _msa_managingpartnerid_value: GUID of the managing partner account
   * - etc.
   */
  const loadContacts = async () => {
    try {
      setLoading(true);
      setError(null);

      // Use the generated service to retrieve contacts
      // The service handles authentication and API calls automatically
      const result = await ContactsService.getAll({
        // Select specific fields including lookup IDs
        // PATTERN: Request only the fields you need for better performance
        select: ['contactid', 'firstname', 'lastname', 'fullname', 'emailaddress1', 'telephone1', 'mobilephone', 'jobtitle', '_createdby_value', '_transactioncurrencyid_value', '_msa_managingpartnerid_value', '_parentcontactid_value', '_owningteam_value', 'createdon', 'modifiedon'],
        // Order by creation date (newest first)
        orderBy: [DEFAULT_SORT_ORDER],
        // Limit to reasonable number of records for performance
        top: MAX_CONTACTS_TO_LOAD,
      });

      if (result.data) {
        setContacts(result.data);
        // Set first contact as default selected for better UX
        if (result.data.length > 0 && !selectedContact) {
          setSelectedContact(result.data[0]);
        }
      } else {
        setError('Failed to load contacts');
      }
    } catch (err) {
      // PATTERN: User-friendly message to state, technical details to console
      setError(`Error loading contacts: ${(err as Error).message}`);
      console.error('Error loading contacts:', err);
    } finally {
      setLoading(false);
    }
  };

  /**
   * CREATE: Add a new contact to Dataverse
   * Uses the generated ContactsService.create() method
   *
   * PATTERN: Setting Lookup Fields with OData Bind Syntax
   * - Format: <fieldname>@odata.bind = /<entity set name>(<guid>)
   * - Example: msa_managingpartnerid@odata.bind = /accounts(12345-guid-67890)
   * - This creates the relationship without fetching the related record
   */
  const createContact = async (formData: ContactFormData): Promise<boolean> => {
    try {
      setError(null);

      // Validate required fields
      if (!formData.firstname || !formData.lastname) {
        setError('First name and last name are required');
        return false;
      }

      // Prepare the contact data
      // Note: ID will be auto-generated by Dataverse
      // Empty strings are converted to undefined (Dataverse treats undefined as "not set")
      const newContact: any = {
        firstname: formData.firstname,
        lastname: formData.lastname,
        emailaddress1: formData.emailaddress1 || undefined,
        telephone1: formData.telephone1 || undefined,
        mobilephone: formData.mobilephone || undefined,
        jobtitle: formData.jobtitle || undefined,
      };

      // Handle lookup field: Link to managing partner account if selected
      // PATTERN: Use OData bind syntax to set lookup relationships
      if (formData.managingpartnerid?.trim()) {
        newContact['msa_managingpartnerid@odata.bind'] =
          `/accounts(${formData.managingpartnerid})`;
      }

      // Call the create method from the generated service
      const result = await ContactsService.create(newContact);

      if (result.data) {
        // Reset form state and reload contacts to show the new record
        setIsCreating(false);
        setSelectedContact(null);
        await loadContacts();
        return true;
      } else {
        setError('Failed to create contact');
        return false;
      }
    } catch (err) {
      // PATTERN: User-friendly message to state, technical details to console
      setError(`Error creating contact: ${(err as Error).message}`);
      console.error('Error creating contact:', err);
      return false;
    }
  };

  /**
   * UPDATE: Modify an existing contact
   * Uses the generated ContactsService.update() method
   *
   * SIMPLIFIED PATTERN FOR DEMO:
   * - Sends all fields to Dataverse (not just changed fields)
   * - Dataverse efficiently handles no-op updates
   * - Simpler code that's easier to understand for a demo/template
   *
   * PRODUCTION ALTERNATIVE:
   * For production apps with complex forms, consider sending only changed fields
   * to minimize payload size and reduce potential for conflicts.
   */
  const updateContact = async (formData: ContactFormData): Promise<boolean> => {
    try {
      if (!selectedContact?.contactid) {
        setError('No contact selected');
        return false;
      }

      setError(null);

      // Prepare the update data
      // PATTERN: Send all fields (simpler for demo, Dataverse handles efficiently)
      const updates: any = {
        firstname: formData.firstname,
        lastname: formData.lastname,
        emailaddress1: formData.emailaddress1 || undefined,
        telephone1: formData.telephone1 || undefined,
        mobilephone: formData.mobilephone || undefined,
        jobtitle: formData.jobtitle || undefined,
      };

      // Handle lookup field update for managing partner
      // Only update if the value has changed
      const currentManagingPartnerId = selectedContact._msa_managingpartnerid_value || '';
      if (formData.managingpartnerid !== currentManagingPartnerId) {
        if (formData.managingpartnerid?.trim()) {
          // Set new managing partner using OData bind syntax
          updates['msa_managingpartnerid@odata.bind'] =
            `/accounts(${formData.managingpartnerid})`;
        }
        // Note: Clearing lookup fields requires a separate DELETE operation
        // to the navigation property reference (not shown in this demo)
      }

      // Call the update method from the generated service
      const result = await ContactsService.update(selectedContact.contactid, updates);

      if (result.data) {
        // Reset form and reload to show updated data
        setSelectedContact(null);
        await loadContacts();
        return true;
      } else {
        setError('Failed to update contact');
        return false;
      }
    } catch (err) {
      // PATTERN: User-friendly message to state, technical details to console
      setError(`Error updating contact: ${(err as Error).message}`);
      console.error('Error updating contact:', err);
      return false;
    }
  };

  /**
   * DELETE: Remove a contact from Dataverse
   * Uses the generated ContactsService.delete() method
   *
   * NOTE: Using browser confirm() for simplicity in demo.
   * In production, consider a custom modal component for better UX.
   */
  const deleteContact = async (contactId: string): Promise<boolean> => {
    try {
      // Confirm before deleting (browser native dialog for demo simplicity)
      if (!confirm('Are you sure you want to delete this contact?')) {
        return false;
      }

      setError(null);

      // Call the delete method from the generated service
      await ContactsService.delete(contactId);

      // If we were editing this contact, reset the form
      if (selectedContact?.contactid === contactId) {
        setSelectedContact(null);
        setIsCreating(false);
      }

      // Reload the contacts list to reflect the deletion
      await loadContacts();
      return true;
    } catch (err) {
      // PATTERN: User-friendly message to state, technical details to console
      setError(`Error deleting contact: ${(err as Error).message}`);
      console.error('Error deleting contact:', err);
      return false;
    }
  };

  /**
   * Start creating a new contact
   * Clears selected contact and enters create mode
   */
  const startCreate = () => {
    setSelectedContact(null);
    setIsCreating(true);
    setError(null);
  };

  /**
   * Select a contact to view/edit
   * Exits create mode and selects the contact for editing
   */
  const selectContact = (contact: Contacts) => {
    setSelectedContact(contact);
    setIsCreating(false);
    setError(null);
  };

  /**
   * Cancel form (create or edit)
   * Returns to list view without saving
   */
  const cancelForm = () => {
    setSelectedContact(null);
    setIsCreating(false);
    setError(null);
  };

  /**
   * Handle form submission (delegates to create or update)
   * Routes to appropriate CRUD operation based on form mode
   */
  const handleFormSubmit = async (formData: ContactFormData): Promise<boolean> => {
    if (isCreating) {
      return await createContact(formData);
    } else {
      return await updateContact(formData);
    }
  };

  return {
    // State
    contacts,
    loading,
    error,
    selectedContact,
    isCreating,
    // Actions
    loadContacts,
    createContact,
    updateContact,
    deleteContact,
    startCreate,
    selectContact,
    cancelForm,
    handleFormSubmit,
  };
}
